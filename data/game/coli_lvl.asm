; =============== Lvl_GetBlockId ===============
; Gets the block ID the sensor coordinates are pointing to and performs basic collision checks.
; The sensors are typically the player's coordinates offset by a particular value.
;
; IN
; - wTargetRelX: X sensor position, relative to the screen's position
; - wTargetRelY: Y sensor position, relative to the screen's position
; OUT
; - A: Block ID
; - C Flag: If set, the block is not solid
; - wPlYCeilMask: Ceiling collision mask
Lvl_GetBlockId:

	; Initialize the ceiling collision mask to the default value for fully solid blocks.
	; This will be updated later on in case we're checking the lower half of a small platform.
	; Note there's only one caller that actually uses this (the ceiling check while jumping).
	ld   a, $F0
	ld   [wPlYCeilMask], a
	
	
	;
	; Build the offset to the level layout.
	;
	; These are mainly generated by dividing the target position by the block width/height.
	;
	; Because actor positions directly map to raw sprite positions, they don't account
	; for the hardware offset, which needs to get subtracted here.
	;
	

	;##
	;
	; X COMPONENT
	;
	; C = wLvlColL - 2 + ((wTargetRelX + (hScrollX % 16) + 32 - OBJ_OFFSET_X) / 16)
	;     Absolute        Relative        Scroll offset within block
	;
	; This is offsetted by 2 blocks in an attempt to do a crude offscreen check that
	; matches how the one for actors works.
	;
	; In practice it doesn't seem to have any effect, as the calling code does a better job
	; with doing proper off-screen checks.
	;
	
	;
	; Calculate the relative block count first
	;
	
	; The horizontal position, unlike the vertical one, can scroll, so it doesn't necessarily start from the start of the block.
	; Since our target positions are relative to the screen, the scroll offset within the leftmost column must be accounted for.
	ldh  a, [hScrollXNybLow]	; C = (hScrollX & $0F) + $18
	add  $20-OBJ_OFFSET_X		; Account for HW offset, and the +2 for the offscreen check
	ld   c, a
	
	ld   a, [wTargetRelX]		; A = (wTargetRelX + C) & $F0
	add  c						; Add that to the target
	
	; At face value we're considering range $F0-$FF as off-screen.
	; Due to the offset of 2 blocks, it's actually checking range $D0-$DF, which is the exact same offscreen range for actors.
	and  $F0					
	cp   $F0					; A >= $F0?
	jr   nc, .solid				; if so, jump
	
	swap a						; Divide by block width to get the count
	and  $0F					; (Not necessary, already did "and $F0" before the swap)
	ld   b, a
	
	;
	; Then calculate the absolute block count.
	;
	ld   a, [wLvlColL]			; Get absolute block count for the leftmost column
	sub  $02					; -2 to counterbalance the +2 from the relative block count
	add  b						; Add the relative one, fixed for partial scroll
	ld   c, a					; To C
	
	;##
	
	;
	; Y COMPONENT (high byte)
	;
	; B = (wTargetRelY - OBJ_OFFSET_Y) / BLOCK_H
	;
	; This is simpler since levels are only 8 blocks tall and there's no way to scroll the screen vertically 
	;
	
	ld   a, [wTargetRelY]		; A = wTargetRelY - $10
	sub  OBJ_OFFSET_Y
	; Also performs its own off-screen check, which is more useful.
	; In practice, anything below or above the level is treated as empty.
	cp   $80					; A >= $80?
	jr   nc, .empty				; If so, jump
	
	swap a						; Divide by block height to get the count
	and  $0F
	ld   b, a					; Now BC has the full wLvlLayout offset
	
	;##
	
	; Read the block off the level layout
	ld   hl, wLvlLayout
	add  hl, bc
	ld   a, [hl]
	
	;
	; BLOCK ID CHECK
	;
	; Determine if the block is solid and store it to the C flag.
	; There's not much to it, all blocks before $22 are empty, the rest are solid.
	;
	; Typically the caller performs more exhaustive block ID checks as needed (ie: for water blocks, ladders).
	; The only special blocks we do check for are the half-solid platforms (see below).
	;
	;

	cp   BLOCKID_HALF_START		; A >= $3C?
	jr   nc, .chkHalfSolid		; If so, it's an half-solid platform
								; Otherwise, it's fully solid or empty
.std:
	cp   BLOCKID_SOLID_START	; Set < result to C flag
	ret
	
.solid:
	ld   a, BLOCKID_SOLID_START	; A = Block ID
	ret							; C Flag = Always clear when we get here
	
.empty:
	xor  a ;BLOCKID_EMPTY_START	; A = Block ID
	scf							; C Flag = Always set
	ret
	
.chkHalfSolid:
	;
	; For half-solid blocks, the upper half is solid, while the bottom half is empty.
	;
	; Given the target Y position is always relative to the top of the screen,
	; the Y position within a block is simply wTargetRelY % 16.
	; If that is >= 8, we're pointing to the empty bottom half, otherwise it's the solid top half.
	;
	ld   a, [wTargetRelY]		; Get Y position on screen
	and  $0F					; Get Y position within block
	cp   $08					; Pointing to the lower half?
	jr   nc, .halfEmpty			; If so, jump (empty)
	
.halfSolid:
	ld   a, $F8					; Otherwise, use half-height solid collision.
	ld   [wPlYCeilMask], a		; This only affects the ceiling check while jumping.
	ld   a, [hl]				; A = Block ID
	cp   BLOCKID_SOLID_START	; C Flag = Always clear
	ret
	
.halfEmpty:
	ld   a, [hl]				; A = Block ID
	scf  						; C Flag = Always set
	ret
	
